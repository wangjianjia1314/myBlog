<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue3 对比 vue2 | gegeの</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="gege">
    
    <link rel="preload" href="/myBlog/assets/css/0.styles.455ea02c.css" as="style"><link rel="preload" href="/myBlog/assets/js/app.e4cc87c6.js" as="script"><link rel="preload" href="/myBlog/assets/js/2.d8ed40ee.js" as="script"><link rel="preload" href="/myBlog/assets/js/37.2a8eeb97.js" as="script"><link rel="prefetch" href="/myBlog/assets/js/10.09be3a32.js"><link rel="prefetch" href="/myBlog/assets/js/11.f51c87cb.js"><link rel="prefetch" href="/myBlog/assets/js/12.d19eff2b.js"><link rel="prefetch" href="/myBlog/assets/js/13.bf9a0931.js"><link rel="prefetch" href="/myBlog/assets/js/14.e7dfb2a3.js"><link rel="prefetch" href="/myBlog/assets/js/15.74e242f8.js"><link rel="prefetch" href="/myBlog/assets/js/16.17d11dff.js"><link rel="prefetch" href="/myBlog/assets/js/17.ca1eec3b.js"><link rel="prefetch" href="/myBlog/assets/js/18.2a45f387.js"><link rel="prefetch" href="/myBlog/assets/js/19.061a99ee.js"><link rel="prefetch" href="/myBlog/assets/js/20.194a4cd6.js"><link rel="prefetch" href="/myBlog/assets/js/21.dc1dabae.js"><link rel="prefetch" href="/myBlog/assets/js/22.17a3e14d.js"><link rel="prefetch" href="/myBlog/assets/js/23.240b9a5c.js"><link rel="prefetch" href="/myBlog/assets/js/24.6fef7378.js"><link rel="prefetch" href="/myBlog/assets/js/25.5fb361cf.js"><link rel="prefetch" href="/myBlog/assets/js/26.a43106fb.js"><link rel="prefetch" href="/myBlog/assets/js/27.69cae185.js"><link rel="prefetch" href="/myBlog/assets/js/28.277482ed.js"><link rel="prefetch" href="/myBlog/assets/js/29.5f3a233c.js"><link rel="prefetch" href="/myBlog/assets/js/3.8b131455.js"><link rel="prefetch" href="/myBlog/assets/js/30.2d9bda54.js"><link rel="prefetch" href="/myBlog/assets/js/31.2ae12ae3.js"><link rel="prefetch" href="/myBlog/assets/js/32.9512cf61.js"><link rel="prefetch" href="/myBlog/assets/js/33.645970ee.js"><link rel="prefetch" href="/myBlog/assets/js/34.0b0de261.js"><link rel="prefetch" href="/myBlog/assets/js/35.fa55cc51.js"><link rel="prefetch" href="/myBlog/assets/js/36.38d14f5a.js"><link rel="prefetch" href="/myBlog/assets/js/38.5837445b.js"><link rel="prefetch" href="/myBlog/assets/js/39.fb142a28.js"><link rel="prefetch" href="/myBlog/assets/js/4.3123f42f.js"><link rel="prefetch" href="/myBlog/assets/js/5.d98e7956.js"><link rel="prefetch" href="/myBlog/assets/js/6.ea87f2ef.js"><link rel="prefetch" href="/myBlog/assets/js/7.4aca074c.js"><link rel="prefetch" href="/myBlog/assets/js/8.db515366.js"><link rel="prefetch" href="/myBlog/assets/js/9.a7914715.js">
    <link rel="stylesheet" href="/myBlog/assets/css/0.styles.455ea02c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/myBlog/" class="home-link router-link-active"><img src="/myBlog/assets/img/ava.png" alt="gegeの" class="logo"> <span class="site-name can-hide">gegeの</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/myBlog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/myBlog/javascript/" class="nav-link">
  javascript
</a></div><div class="nav-item"><a href="/myBlog/css/" class="nav-link">
  css
</a></div><div class="nav-item"><a href="/myBlog/react/" class="nav-link">
  react
</a></div><div class="nav-item"><a href="/myBlog/vue/" class="nav-link router-link-active">
  vue
</a></div><div class="nav-item"><a href="/myBlog/html/" class="nav-link">
  html
</a></div><div class="nav-item"><a href="/myBlog/git/" class="nav-link">
  git
</a></div><div class="nav-item"><a href="/myBlog/webpack/" class="nav-link">
  webpack
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/myBlog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/myBlog/javascript/" class="nav-link">
  javascript
</a></div><div class="nav-item"><a href="/myBlog/css/" class="nav-link">
  css
</a></div><div class="nav-item"><a href="/myBlog/react/" class="nav-link">
  react
</a></div><div class="nav-item"><a href="/myBlog/vue/" class="nav-link router-link-active">
  vue
</a></div><div class="nav-item"><a href="/myBlog/html/" class="nav-link">
  html
</a></div><div class="nav-item"><a href="/myBlog/git/" class="nav-link">
  git
</a></div><div class="nav-item"><a href="/myBlog/webpack/" class="nav-link">
  webpack
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>vue</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/myBlog/vue/methods.html" class="sidebar-link">事件</a></li><li><a href="/myBlog/vue/underlying.html" class="sidebar-link">原理</a></li><li><a href="/myBlog/vue/v3.html" aria-current="page" class="active sidebar-link">v3</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/vue/v3.html#vue3-对比-vue2" class="sidebar-link">vue3 对比 vue2</a></li><li class="sidebar-sub-header"><a href="/myBlog/vue/v3.html#reactive" class="sidebar-link">reactive</a></li><li class="sidebar-sub-header"><a href="/myBlog/vue/v3.html#ref" class="sidebar-link">ref</a></li><li class="sidebar-sub-header"><a href="/myBlog/vue/v3.html#ref-解包" class="sidebar-link">ref 解包</a></li><li class="sidebar-sub-header"><a href="/myBlog/vue/v3.html#reactive-解构的数据无法支持响应式" class="sidebar-link">reactive 解构的数据无法支持响应式</a></li><li class="sidebar-sub-header"><a href="/myBlog/vue/v3.html#v-show-v-if" class="sidebar-link">v-show v-if</a></li><li class="sidebar-sub-header"><a href="/myBlog/vue/v3.html#v-for-v-if" class="sidebar-link">v-for v-if</a></li><li class="sidebar-sub-header"><a href="/myBlog/vue/v3.html#watch-vs-watcheffect" class="sidebar-link">watch vs. watchEffect</a></li><li class="sidebar-sub-header"><a href="/myBlog/vue/v3.html#ref-访问调用子组件的方法" class="sidebar-link">ref 访问调用子组件的方法</a></li><li class="sidebar-sub-header"><a href="/myBlog/vue/v3.html#vue3-移除了-on-off-可以使用-mitt-库来代替" class="sidebar-link">vue3 移除了$on $off 可以使用 mitt 库来代替</a></li><li class="sidebar-sub-header"><a href="/myBlog/vue/v3.html#vue3-deep" class="sidebar-link">vue3 /deep/</a></li><li class="sidebar-sub-header"><a href="/myBlog/vue/v3.html#常见状态码" class="sidebar-link">常见状态码</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="vue3-对比-vue2"><a href="#vue3-对比-vue2" class="header-anchor">#</a> vue3 对比 vue2</h2> <ul><li><p>组合式 api 可以将同一个逻辑关注点代码收集到一起 方便维护</p></li> <li><p>选项式 api 只能根据提供对应的选项，编写指定的内容，不利于维护。</p></li> <li><p>setUp 取代了 create beforeCreate，可以在 setUp 中做这两个钩子的事情 在 setUp 中 this 获取不到组件实力 因为在执行时机 组件实例还未被创建。</p></li> <li><p>响应式 api 的修改</p> <ul><li>在 vue2 中，数据劫持是通过 Object.defineProperty</li> <li>这个 API 有一些缺陷，并不能检测对象属性的添加和删除</li> <li>vue3 是通过 proxy 监听整个对象，那么对于删除还是监听当然也能监听到</li></ul></li> <li><p>逻辑复用</p> <ul><li>在 vue2 中，我们是通过 mixin 实现功能混合，如果多个 mixin 混合，会存在两个非常明显的问题：命名冲突和数据来源不清晰</li> <li>vue3 而通过 composition 这种形式，可以将一些复用的代码抽离出来作为一个函数，只要的使用的地方直接进行调用即可</li></ul></li> <li><p>更小</p> <ul><li>api 的移除
<ul><li>1.vue3 移除了一些不常用的 api 比如 不再支持 keycode 作为 v-on 的修饰符 推荐使用按键名</li> <li>2.$on，$off 和 $once 实例方法被移除 vue2 常用于$on $emit 创建全局事件监听器 实现 eventBus 来实现数据共享</li> <li>3.删除过滤器 filter 可以使用计算属性代替</li> <li>4.移除内联特性 内联模板 Attribute</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token number">2</span><span class="token punctuation">.</span>x <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> inline<span class="token operator">-</span>template属性可以将其内部内容用作模板，而不是将其作为分发内容 <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>my<span class="token operator">-</span>component inline<span class="token operator">-</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>它们被编译为组件自己的模板<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>不是父级所包含的内容。<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>my<span class="token operator">-</span>component<span class="token operator">&gt;</span>
</code></pre></div><ul><li>5.$children 已移除 $children 实例 property 已从 Vue 3.0 中移除，不再支持.在vue3中，如果要访问子组件实例，建议使用$refs</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token number">2</span><span class="token punctuation">.</span>x <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>my<span class="token operator">-</span>button<span class="token operator">&gt;</span>Change logo<span class="token operator">&lt;</span><span class="token operator">/</span>my<span class="token operator">-</span>button<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">)</span> <span class="token comment">// [VueComponent]</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>引入 tree-shaking 可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了</li> <li>没有被使用的 API 的相关代码可以在最终打包时被移除</li> <li>原理</li> <li>1 作为模块顶层的语句 import 模块的依赖关系时确定的。可以进行静态分析。</li> <li>2 分析程序流，判断哪些变量未被啥用、引用，进而删除此代码。</li></ul></li> <li><p>更快</p> <ul><li><p>// old arr</p></li> <li><p>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;]</p></li> <li><p>// new arr</p></li> <li><p>[&quot;a&quot;, &quot;b&quot;, &quot;d&quot;, &quot;f&quot;, &quot;c&quot;, &quot;e&quot;, &quot;x&quot;, &quot;y&quot;, &quot;g&quot;, &quot;h&quot;]</p></li> <li><p>双端对比 比较结束后 相同的复用 不相同的乱序在进一步处理</p></li> <li><p>对于相同节点 要去判断 key type</p></li> <li><p>第一步 左边按需查找,如果节点不能复用 则停止</p></li> <li><p>第二步 右边按需查找，如果节点不能复用 则停止</p></li> <li><p>第三步 老节点没有了 新节点还有 就要去做新增 mountElement()</p></li> <li><p>第四步 新节点没有 老节点还有 就要去做删除 unmount（）</p></li> <li><p>old[c,d,e,f] new[d,f,c,e,x,y]</p></li> <li><p>第五步 新老节点都还有 是一中乱序的</p></li> <li><p>通过 Map 保存新元素的未匹配的元素 为什么用 Map 因为可以更快速的通过 key value 的形势查找</p></li> <li><p>const keyToNewIndexMap = new Map()</p></li> <li><p>通过游标循环 找到需要保存 map 结构的元素 key=节点的 key value = index</p></li> <li><p>{d:2,f:3,c:4,e:5,x:6,y:7}</p></li> <li><p>遍历老元素进行查找 获取更新节点的总个数 达到就不去在便利 直接删除老节点还存在 未遍历的 newarr - 执行到第五步的 i = 新节点的总个数</p></li> <li><p>通过老元素的 key 去 keyToNewIndexMap 中去查找是否会命中，</p></li> <li><p>没有的话 就会 unmount 删除</p></li> <li><p>此刻会生成数组 newIndexToOldIndexMap 数组个数是计算出来新节点的总个数的长度 初始值为 0</p></li> <li><p>复用的节点生成标记 newIndexToOldIndexMap 的下标保存老元素的下标</p></li> <li><p>有的话 复用节点 patch()</p></li> <li><p>1diff 算法优化</p></li> <li><p>静态节点的优化</p></li> <li><p>render 函数主要用来生成虚拟 dom</p></li> <li><p>vue3 标记了标记了 dynamicChildren 动态节点</p></li> <li><p>在 path 阶段，只会比较动态节点，静态节点直接略过，而 vue2 中 还会进入 patch 判定为静态节点直接 return。vue3 静态节点不会进入 patch。</p></li> <li><p>vue3 diff 采用双端对比</p> <ul><li>// old arr</li> <li>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;]</li> <li>// new arr</li> <li>[&quot;a&quot;, &quot;b&quot;, &quot;d&quot;, &quot;f&quot;, &quot;c&quot;, &quot;e&quot;, &quot;x&quot;, &quot;y&quot;, &quot;g&quot;, &quot;h&quot;]</li> <li>第一步 从头到尾的比对开始 比对方式 a b 是相同的节点（sameVnode）进入 path 到 [c] 停止</li> <li>第二步 从尾到头的比对开始 比对 h g 到 [f] 停止;</li> <li>第三步 旧数据比对完毕的时候 新数据多余的表明时新增 进入 mount</li> <li>第四步 新数据比对完毕 旧数据还存在的 表示时多余的 进入 unmount</li> <li>第五步 进入到这里 说明有乱序</li> <li>根据没有比较的数据 新建一个 Map keyToNewIndexMap[d:2,f:3,c:4,e:5,x:6,y:7]</li> <li>循环旧的剩余数据 找到未比较的数据索引 newIndexToOldIndexMap[4(d),6(f),3(c),5(e),0,0] 同时进行补 0</li> <li>如果旧数据能在新数据里找到 和之前的 patch</li> <li>没找到 说明时删除 unmount 掉</li> <li>其实到这一步，已经很好办了，从尾到头循环一下 newIndexToOldIndexMap</li> <li>是 0 的，说明是新增的数据，就 mount 进去</li> <li>非 0 的，说明在旧数据里，我们只要把它们移动到对应 index 的前面就行了</li></ul></li> <li><p>vue2 diff 采用双指针循环对比</p> <ul><li>// old arr</li> <li>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;]</li> <li>// new arr</li> <li>[&quot;a&quot;, &quot;b&quot;, &quot;d&quot;, &quot;f&quot;, &quot;c&quot;, &quot;e&quot;, &quot;x&quot;, &quot;y&quot;, &quot;g&quot;, &quot;h&quot;]</li> <li>vue2 整体上也差不多，但是它只有一个双指针的循环</li> <li>首先比较新旧的头，直到第一个非 sameVNOde</li> <li>然后从尾开始比较，直到第一个非 sameVNOde</li> <li>然后会做头尾，尾头的比较，这种是考虑到会左移和右移操作</li> <li>[&quot;d&quot;, &quot;f&quot;, &quot;c&quot;, &quot;e&quot;, &quot;x&quot;, &quot;y&quot;] 未比较的</li> <li>接着会尝试从 &quot;d&quot; 开始去旧数据里找到 index 然后移动到旧数据还未比较数据的头部</li> <li>把 d 移动到 c 之前</li> <li>把 f 移动到 c 之前</li> <li>下轮循环发现新旧都是 c 于是 patch 完之后继续</li> <li>下轮循环发现新旧都是 e 于是 patch 完之后继续</li> <li>发现 x 不在旧数据中，createElm(x)</li> <li>发现 x 不在旧数据中，createElm(y)</li> <li>可以发现，vue2 在 diff 算法处理无序数据的判断是在最后</li> <li>每次处理之前，会依次判断之前所有的 if</li> <li>而 vue3 中，会找到所有需要移动的节点，直接移动</li> <li>还有一点 vue3 中 对于首尾替换的额外判断似乎也取消了</li></ul></li> <li><p>事件优化</p></li> <li><p>如果开启了 cacheHandlers 则会缓存我们的事件，事件的变化不会引起重新渲染</p></li> <li><p>vue2 中看到其实每次更新，render 函数跑完之后 vnode 绑定的事件都是一个全新生成的 function，就算它们内部的代码是一样的所以 events 的 update 钩子，几乎每次都能命中，然后更新一下函数的引用</p></li></ul></li></ul> <h2 id="reactive"><a href="#reactive" class="header-anchor">#</a> reactive</h2> <ul><li>reactive 的局限性
<ul><li>1.仅对对象类型的有效，string number boolean 这样的原始类型无效</li> <li>2.因为响应系统是通过属性访问进行追踪的，因此必须保持该响应式对象的相同引用。</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// n 是一个局部变量，同 state.count</span>
<span class="token comment">// 失去响应性连接</span>
<span class="token keyword">let</span> n <span class="token operator">=</span> state<span class="token punctuation">.</span>count<span class="token punctuation">;</span>
<span class="token comment">// 不影响原始的 state</span>
n<span class="token operator">++</span><span class="token punctuation">;</span>

<span class="token comment">// count 也和 state.count 失去了响应性连接</span>
<span class="token keyword">let</span> <span class="token punctuation">{</span> count <span class="token punctuation">}</span> <span class="token operator">=</span> state<span class="token punctuation">;</span>
<span class="token comment">// 不会影响原始的 state</span>
count<span class="token operator">++</span><span class="token punctuation">;</span>

<span class="token comment">// 该函数接收一个普通数字，并且</span>
<span class="token comment">// 将无法跟踪 state.count 的变化</span>
<span class="token function">callSomeFunction</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="ref"><a href="#ref" class="header-anchor">#</a> ref</h2> <ul><li>reactive 的限制是因为 javascript 没有作用于值类型的引用机制，为此 Vue 提供了 ref 方法可以使用任何值类型的响应式。</li> <li>ref 将传入的参数的值包装为一个带 .value 属性的 ref 对象</li> <li>和响应式对象的属性类似，ref 的 .value 属性也是响应式的。同时，当值为对象类型时，会用 reactive() 自动转换它的 .value。</li> <li>ref() 让我们能创造一种对任意值的 “引用”，并能够在不丢失响应性的前提下传递这些引用。这个功能很重要</li> <li>ref 被传递给函数或是从一般对象上被解构时，不会丢失响应性：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 该函数接收一个 ref</span>
<span class="token comment">// 需要通过 .value 取值</span>
<span class="token comment">// 但它会保持响应性</span>
<span class="token function">callSomeFunction</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 仍然是响应式的</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token punctuation">}</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span>
</code></pre></div><h2 id="ref-解包"><a href="#ref-解包" class="header-anchor">#</a> ref 解包</h2> <ul><li>当 ref 在模板中作为顶层属性被访问时，它们会被自动“解包”，所以不需要使用 .value。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token operator">&lt;</span>script setup<span class="token operator">&gt;</span>
  <span class="token keyword">import</span> <span class="token punctuation">{</span> ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
  <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    count<span class="token punctuation">.</span>value<span class="token operator">++</span>
  <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">&quot;increment&quot;</span><span class="token operator">&gt;</span>
    <span class="token punctuation">{</span><span class="token punctuation">{</span> count <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 无需 <span class="token punctuation">.</span>value <span class="token operator">--</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
</code></pre></div><ul><li>请注意，仅当 ref 是模板渲染上下文的顶层属性时才适用自动“解包”。 例如， foo 是顶层属性，但 object.foo 不是。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>下面的表达式将不会像预期的那样工作：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token punctuation">{</span>
    object<span class="token punctuation">.</span>foo <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>我们可以通过将 foo 改成顶层属性来解决这个问题：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span> <span class="token operator">=</span> object<span class="token punctuation">;</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">{</span>
    foo <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="reactive-解构的数据无法支持响应式"><a href="#reactive-解构的数据无法支持响应式" class="header-anchor">#</a> reactive 解构的数据无法支持响应式</h2> <ul><li>reactive 无法劫持基本类型的数据。 对于基本类型的数据，函数传递或者对象结构时，会丢失数据的引用。</li> <li>结构相当于 直接绕过代理 直接进行取值 声明新的变量。</li> <li>ref 的基本类型的数据 只能通过创建一个对象，将数据保存到 value 中。去劫持 value 的 get 和 set。</li> <li>toRefs 遍历对象 讲属性转成 Ref 的数据 这样结构出来的还是 Ref 数据。就会保持了响应式。</li></ul> <h2 id="v-show-v-if"><a href="#v-show-v-if" class="header-anchor">#</a> v-show v-if</h2> <ul><li>v-show 不支持在 template&gt; 元素上使用，也不能和 v-else 搭配使用。</li> <li>v-if 可以在 template 元素上使用</li> <li>v-if 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。</li></ul> <h2 id="v-for-v-if"><a href="#v-for-v-if" class="header-anchor">#</a> v-for v-if</h2> <ul><li>当 v-if 和 v-for 同时存在于一个元素上的时候，v-if 会首先被执行</li></ul> <h2 id="watch-vs-watcheffect"><a href="#watch-vs-watcheffect" class="header-anchor">#</a> watch vs. watchEffect</h2> <ul><li>watch 和 watchEffect 的主要功能是相同的，都能响应式地执行回调函数。它们的区别是追踪响应式依赖的方式不同：</li> <li>watch 只追踪明确定义的数据源，不会追踪在回调中访问到的东西；默认情况下，只有在数据源发生改变时才会触发回调；watch 可以访问侦听数据的新值和旧值。</li> <li>watchEffect 会初始化执行一次，在副作用发生期间追踪依赖，自动分析出侦听数据源；</li> <li>watchEffect 无法访问侦听数据的新值和旧值。</li> <li>watchEffect 第三个参数配置对象
<ul><li>flush: 'post' 默认组件渲染前执行 设置延迟到组件渲染之后执行 watchPostEffect() 使用 flush: 'post' 选项时的别名。</li> <li>flush: 'sync'</li></ul></li></ul> <h2 id="ref-访问调用子组件的方法"><a href="#ref-访问调用子组件的方法" class="header-anchor">#</a> ref 访问调用子组件的方法</h2> <ul><li>子组件需要暴露对应的方法和数据 父组件才可以调用</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">defineExpose</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  ruleFormRef<span class="token punctuation">,</span>
  submitForm<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="vue3-移除了-on-off-可以使用-mitt-库来代替"><a href="#vue3-移除了-on-off-可以使用-mitt-库来代替" class="header-anchor">#</a> vue3 移除了$on $off 可以使用 mitt 库来代替</h2> <h2 id="vue3-deep"><a href="#vue3-deep" class="header-anchor">#</a> vue3 /deep/</h2> <ul><li>v3 废弃了 /deep/ ::v-deep 的写法</li> <li>使用 :deep(.class){}</li></ul> <h2 id="常见状态码"><a href="#常见状态码" class="header-anchor">#</a> 常见状态码</h2> <ul><li>1 系列表示信息响应</li> <li>2 系列表示成功响应</li> <li>3 系列表示重定向响应</li> <li>4 系列表示客户端错误</li> <li>5 系列表示服务端错误</li> <li>200 服务器成功返回用户请求的数据</li> <li>201 新建或者修改数据成功</li> <li>204 用户删除数据成功</li> <li>401 用户没有权限</li> <li>403 用户得到授权</li> <li>404 用户发出请求 访问了不存在的记录 服务器没有进行操作</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/myBlog/vue/underlying.html" class="prev">
        原理
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/myBlog/assets/js/app.e4cc87c6.js" defer></script><script src="/myBlog/assets/js/2.d8ed40ee.js" defer></script><script src="/myBlog/assets/js/37.2a8eeb97.js" defer></script>
  </body>
</html>
